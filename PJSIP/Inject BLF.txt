########### /pjsip/pjsip-simple/

>>> добавить blf.h и blf.c в (include) (src)
>>> добавить dialog_info.h и dialog_info.c в (include) (src)


>>> в /pjsip/include/pjsip_simple.h

+++ #include <pjsip-simple/blf.h>

>>> в /pjsip/build/Makefile
	+++ blf.o dialog-info.o


>>> модификация /pjsip/include/pjsip/sip_config.h

----------------------------------
#ifndef PJSIP_BLF_DEFAULT_EXPIRES
#   define PJSIP_BLF_DEFAULT_EXPIRES       600
#endif

#ifndef PJSIP_BLF_BAD_CONTENT_RESPONSE
#   define PJSIP_BLF_BAD_CONTENT_RESPONSE  488
#endif

--------------------------------------

>>> модификация evsub.h (include)

-----------------------------

struct pjsip_evsub_blf_user
{
    /**
     * This callback is called when subscription state has changed.
     * Application MUST be prepared to receive NULL event and events with
     * type other than PJSIP_EVENT_TSX_STATE
     *
     * This callback is OPTIONAL.
     *
     * @param sub   The subscription instance.
     * @param event The event that has caused the state to change,
     *          which may be NULL or may have type other than
     *          PJSIP_EVENT_TSX_STATE.
     */
    void (*on_evsub_state)( pjsip_evsub *sub, pjsip_event *event);

    /**
     * This callback is called when transaction state has changed.
     *
     * @param sub   The subscription instance.
     * @param tsx   Transaction.
     * @param event The event.
     */
    void (*on_tsx_state)(pjsip_evsub *sub, pjsip_transaction *tsx,
             pjsip_event *event);

    /**
     * This callback is called when incoming SUBSCRIBE (or any method that
     * establishes the subscription in the first place) is received. It
     * allows application to specify what response should be sent to
     * remote, along with additional headers and message body to be put
     * in the response.
     *
     * This callback is OPTIONAL.
     *
     * However, implementation MUST send NOTIFY request upon receiving this
     * callback. The suggested behavior is to call
     * #pjsip_evsub_current_notify(), since this function takes care
     * about unsubscription request and calculates the appropriate expiration
     * interval.
     */
    void (*on_rx_refresh)( pjsip_evsub *sub,
               pjsip_rx_data *rdata,
               int *p_st_code,
               pj_str_t **p_st_text,
               pjsip_hdr *res_hdr,
               pjsip_msg_body **p_body);

    /**
     * This callback is called when client/subscriber received incoming
     * NOTIFY request. It allows the application to specify what response
     * should be sent to remote, along with additional headers and message
     * body to be put in the response.
     *
     * This callback is OPTIONAL. When it is not implemented, the default
     * behavior is to respond incoming NOTIFY request with 200 (OK).
     *
     * @param sub   The subscription instance.
     * @param rdata The received NOTIFY request.
     * @param p_st_code Application MUST set the value of this argument with
     *          final status code (200-699) upon returning from the
     *          callback.
     * @param p_st_text Custom status text, if any.
     * @param res_hdr   Upon return, application can put additional headers
     *          to be sent in the response in this list.
     * @param p_body    Application MAY specify message body to be sent in
     *          the response.
     */
    void (*on_rx_notify)(pjsip_evsub *sub,
             pjsip_rx_data *rdata,
             int *p_st_code,
             pj_str_t **p_st_text,
             pjsip_hdr *res_hdr,
             pjsip_msg_body **p_body);

    /**
     * This callback is called when it is time for the client to refresh
     * the subscription.
     *
     * This callback is OPTIONAL when PJSIP package such as presence or
     * refer is used; the event package will refresh subscription by sending
     * SUBSCRIBE with the interval set to current/last interval.
     *
     * @param sub   The subscription instance.
     */
    void (*on_client_refresh)(pjsip_evsub *sub);

    /**
     * This callback is called when server doesn't receive subscription
     * refresh after the specified subscription interval.
     *
     * This callback is OPTIONAL when PJSIP package such as presence or
     * refer is used; the event package send NOTIFY to terminate the
     * subscription.
     */
    void (*on_server_timeout)(pjsip_evsub *sub);

};

/**
 * @see pjsip_evsub_user
 */
typedef struct pjsip_evsub_blf_user pjsip_evsub_blf_user;


-----------------------------


>>> модификация presence_body.c (src)


-----------------------------
 #include <pjsip-simple/blf.h>

+++

static const pj_str_t STR_DIALOG_INFO_XML = { "dialog-info+xml", 15 };

+++

PJ_DEF(pj_status_t) pjsip_blf_parse_dialog_info( pjsip_rx_data *rdata,
                       pj_pool_t *pool,
                       pjsip_blf_status *blf_status)
{
    return pjsip_blf_parse_dialog_info2((char*)rdata->msg_info.msg->body->data,
                  rdata->msg_info.msg->body->len,
                  pool, blf_status);
}

PJ_DEF(pj_status_t) pjsip_blf_parse_dialog_info2(char *body, unsigned body_len,
                       pj_pool_t *pool,
                       pjsip_blf_status *blf_status)
{
    pjdialog_info_dialog_info *dialog_info;
    pjdialog_info_dialog *dialog;

    dialog_info = pjdialog_info_parse(pool, body, body_len);
    if (dialog_info == NULL)
        return PJSIP_SIMPLE_EBADPIDF;

    blf_status->info_cnt = 0;

    dialog = pjdialog_info_dialog_info_get_dialog(dialog_info);
    pj_strdup(pool, &blf_status->info[blf_status->info_cnt].dialog_info_entity, pjdialog_info_dialog_info_get_entity(dialog_info));
    pj_strdup(pool, &blf_status->info[blf_status->info_cnt].dialog_info_state, pjdialog_info_dialog_info_get_state(dialog_info));
    pj_strdup(pool, &blf_status->info[blf_status->info_cnt].dialog_info_version, pjdialog_info_dialog_info_get_version(dialog_info));
    
    if (dialog)
    {
        blf_status->info[blf_status->info_cnt].dialog_node = pj_xml_clone(pool, dialog);

        pj_strdup(pool, &blf_status->info[blf_status->info_cnt].dialog_id, pjdialog_info_dialog_get_id(dialog));
        pj_strdup(pool, &blf_status->info[blf_status->info_cnt].dialog_call_id, pjdialog_info_dialog_get_call_id(dialog));
        pj_strdup(pool, &blf_status->info[blf_status->info_cnt].dialog_remote_tag, pjdialog_info_dialog_get_remote_tag(dialog));
        pj_strdup(pool, &blf_status->info[blf_status->info_cnt].dialog_local_tag, pjdialog_info_dialog_get_local_tag(dialog));
        pj_strdup(pool, &blf_status->info[blf_status->info_cnt].dialog_direction, pjdialog_info_dialog_get_direction(dialog));
        pj_strdup(pool, &blf_status->info[blf_status->info_cnt].dialog_state, pjdialog_info_dialog_get_state(dialog));
        pj_strdup(pool, &blf_status->info[blf_status->info_cnt].dialog_state_code, pjdialog_info_dialog_get_state_code(dialog));
        pj_strdup(pool, &blf_status->info[blf_status->info_cnt].dialog_duration, pjdialog_info_dialog_get_duration(dialog));

        pjdialog_info_local * local =pjdialog_info_dialog_get_local(dialog);
        if (local)
        {
            pj_strdup(pool, &blf_status->info[blf_status->info_cnt].local_identity, pjdialog_info_local_get_identity(local));
            pj_strdup(pool, &blf_status->info[blf_status->info_cnt].local_identity_display, pjdialog_info_local_get_identity_display(local));
            pj_strdup(pool, &blf_status->info[blf_status->info_cnt].local_target_uri, pjdialog_info_local_get_target_uri(local));
        }
        else {
            blf_status->info[blf_status->info_cnt].local_identity.ptr = NULL;
            blf_status->info[blf_status->info_cnt].local_identity_display.ptr = NULL;
            blf_status->info[blf_status->info_cnt].local_target_uri.ptr = NULL;
        }

        pjdialog_info_remote * remote =pjdialog_info_dialog_get_remote(dialog);
        if (remote)
        {
            pj_strdup(pool, &blf_status->info[blf_status->info_cnt].remote_identity, pjdialog_info_remote_get_identity(remote));
            pj_strdup(pool, &blf_status->info[blf_status->info_cnt].remote_identity_display, pjdialog_info_remote_get_identity_display(remote));
            pj_strdup(pool, &blf_status->info[blf_status->info_cnt].remote_target_uri, pjdialog_info_remote_get_target_uri(remote));
        }
        else {
            blf_status->info[blf_status->info_cnt].remote_identity.ptr = NULL;
            blf_status->info[blf_status->info_cnt].remote_identity_display.ptr = NULL;
            blf_status->info[blf_status->info_cnt].remote_target_uri.ptr = NULL;
        }
    }
    else
        blf_status->info[blf_status->info_cnt].dialog_node = NULL;
    return PJ_SUCCESS;
}


-----------------------------


########### pjsip/pjsua-lib

>>> pjsip/pjsua-lib/include/pjsua.h

+++ в struct pjsua_callback добавить коллбеки

-------------------------------


    void (*on_buddy_blf_state)(pjsua_buddy_id buddy_id);

    void (*on_buddy_evsub_blf_state)(pjsua_buddy_id buddy_id,
			 pjsip_evsub *sub,
			 pjsip_event *event);


+++


typedef struct pjsua_buddy_blf_info
{
    /**
     * The buddy ID.
     */
    pjsua_buddy_id  id;

    /**
     * The full URI of the buddy, as specified in the configuration.
     */
    pj_str_t        uri;

    /* BLF Dialog-Info id */
    pj_str_t        dialog_id;

    /* BLF Dialog-Info state */
    pj_str_t        dialog_info_state;

    /* BLF Dialog-Info version */
    pj_str_t        dialog_info_version;

    /* BLF Dialog-Info entity */
    pj_str_t        dialog_info_entity;

    /* BLF Dialog call_id */
    pj_str_t        dialog_call_id;

    /* BLF Dialog remote_tag */
    pj_str_t        dialog_remote_tag;

    /* BLF Dialog local_tag */
    pj_str_t        dialog_local_tag;

    /* BLF Dialog direction */
    pj_str_t        dialog_direction;

    /* BLF dialog state */
    pj_str_t        dialog_state;

    /* BLF dialog state code*/
    pj_str_t        dialog_state_code;

    /* BLF dialog duration */
    pj_str_t        dialog_duration;

    /* BLF local identity */
    pj_str_t        local_identity;

    /* BLF local identity_display */
    pj_str_t        local_identity_display;

    /* BLF local target uri */
    pj_str_t        local_target_uri;


    /* BLF remote identity */
    pj_str_t        remote_identity;

    /* BLF remote identity_display */
    pj_str_t        remote_identity_display;

    /* BLF remote target uri */
    pj_str_t        remote_target_uri;


    /**
     * If \a monitor_pres is enabled, this specifies the last state of the
     * presence subscription. If presence subscription session is currently
     * active, the value will be PJSIP_EVSUB_STATE_ACTIVE. If presence
     * subscription request has been rejected, the value will be
     * PJSIP_EVSUB_STATE_TERMINATED, and the termination reason will be
     * specified in \a sub_term_reason.
     */
    pjsip_evsub_state   sub_state;

    /**
     * String representation of subscription state.
     */
    const char         *sub_state_name;

    /**
     * Specifies the last presence subscription termination code. This would
     * return the last status of the SUBSCRIBE request. If the subscription
     * is terminated with NOTIFY by the server, this value will be set to
     * 200, and subscription termination reason will be given in the
     * \a sub_term_reason field.
     */
    unsigned        sub_term_code;

    /**
     * Specifies the last presence subscription termination reason. If
     * presence subscription is currently active, the value will be empty.
     */
    pj_str_t        sub_term_reason;

    /**
     * Internal buffer.
     */
   char        buf_[512];

} pjsua_buddy_blf_info;


+++


/**
 * Get detailed buddy info.
 *
 * @param buddy_id	The buddy identification.
 * @param info		Pointer to receive information about buddy.
 *
 * @return		PJ_SUCCESS on success, or the appropriate error code.
 */
PJ_DECL(pj_status_t) pjsua_buddy_get_blf_info(pjsua_buddy_id buddy_id,
                      pjsua_buddy_blf_info *info);

/**
 * Add new buddy to the buddy list. If blf subscription is enabled
 * for this buddy, this function will also start the blf subscription
 * session immediately.
 *
 * @param buddy_cfg Buddy configuration.
 * @param p_buddy_id    Pointer to receive buddy ID.
 *
 * @return      PJ_SUCCESS on success, or the appropriate error code.
 */
PJ_DECL(pj_status_t) pjsua_buddy_add_blf(const pjsua_buddy_config *buddy_cfg,
                     pjsua_buddy_id *p_buddy_id);



/**
 * Enable/disable buddy's presence monitoring. Once buddy's presence is
 * subscribed, application will be informed about buddy's presence status
 * changed via \a on_buddy_state() callback.
 *
 * @param buddy_id	Buddy identification.
 * @param subscribe	Specify non-zero to activate presence subscription to
 *			the specified buddy.
 *
 * @return		PJ_SUCCESS on success, or the appropriate error code.
 */
PJ_DECL(pj_status_t) pjsua_buddy_subscribe_blf(pjsua_buddy_id buddy_id,
                        pj_bool_t subscribe);


/**
 * Update the presence information for the buddy. Although the library
 * periodically refreshes the presence subscription for all buddies, some
 * application may want to refresh the buddy's presence subscription
 * immediately, and in this case it can use this function to accomplish
 * this.
 *
 * Note that the buddy's presence subscription will only be initiated
 * if presence monitoring is enabled for the buddy. See 
 * #pjsua_buddy_subscribe_pres() for more info. Also if presence subscription
 * for the buddy is already active, this function will not do anything.
 *
 * Once the presence subscription is activated successfully for the buddy,
 * application will be notified about the buddy's presence status in the
 * on_buddy_state() callback.
 *
 * @param buddy_id	Buddy identification.
 *
 * @return		PJ_SUCCESS on success, or the appropriate error code.
 */
PJ_DECL(pj_status_t) pjsua_buddy_update_blf(pjsua_buddy_id buddy_id);


-------------------------------

>>> в pjsip/pjsua-lib/include/pjsua_internal.h

+++ в struct pjsua_buddy

    pjsip_blf_status    blf_status; /**< Buddy blf status.     */


>>> pjsip/pjsua-lib/src/pjsua_pres.c

+++

static void subscribe_buddy_blf(pjsua_buddy_id buddy_id);
static void unsubscribe_buddy_blf(pjsua_buddy_id buddy_id);

+++ 

----------------------------------

/*
 * Get detailed buddy blf info.
 */
PJ_DEF(pj_status_t) pjsua_buddy_get_blf_info( pjsua_buddy_id buddy_id,
                      pjsua_buddy_blf_info *info)
{
    unsigned total=0;
    struct buddy_lock lck;
    pjsua_buddy *buddy;
    pj_status_t status;

    PJ_ASSERT_RETURN(pjsua_buddy_is_valid(buddy_id),  PJ_EINVAL);

    pj_bzero(info, sizeof(pjsua_buddy_blf_info));

    status = lock_buddy("pjsua_buddy_get_blf_info()", buddy_id, &lck, 0);
    if (status != PJ_SUCCESS)
        return status;

    buddy = lck.buddy;
    info->id = buddy->index;
    if (pjsua_var.buddy[buddy_id].uri.slen == 0) {
        unlock_buddy(&lck);
        return PJ_SUCCESS;
    }

    /* uri */
    info->uri.ptr = info->buf_ + total;
    pj_strncpy(&info->uri, &buddy->uri, sizeof(info->buf_)-total);
    total += info->uri.slen;

    if (pjsua_var.buddy[buddy_id].blf_status.info[0].dialog_info_state.slen > 0) {
        info->dialog_info_state.ptr = info->buf_ + total;
        pj_strncpy(&info->dialog_info_state, &pjsua_var.buddy[buddy_id].blf_status.info[0].dialog_info_state, pjsua_var.buddy[buddy_id].blf_status.info[0].dialog_info_state.slen);
        total += info->dialog_info_state.slen;
    }

    if (pjsua_var.buddy[buddy_id].blf_status.info[0].dialog_info_version.slen > 0) {
        info->dialog_info_version.ptr = info->buf_ + total;
        pj_strncpy(&info->dialog_info_version, &pjsua_var.buddy[buddy_id].blf_status.info[0].dialog_info_version, pjsua_var.buddy[buddy_id].blf_status.info[0].dialog_info_version.slen);
        total += info->dialog_info_version.slen;
    }

    if (pjsua_var.buddy[buddy_id].blf_status.info[0].dialog_info_entity.slen > 0) {
        info->dialog_info_entity.ptr = info->buf_ + total;
        pj_strncpy(&info->dialog_info_entity, &pjsua_var.buddy[buddy_id].blf_status.info[0].dialog_info_entity, pjsua_var.buddy[buddy_id].blf_status.info[0].dialog_info_entity.slen);
        total += info->dialog_info_entity.slen;
    }
    if (pjsua_var.buddy[buddy_id].blf_status.info[0].dialog_state.slen == 0) {
        info->dialog_state.ptr = info->buf_ + total;
        info->dialog_state = pj_str("NULL");
        total += info->dialog_state.slen;
    }
    if (pjsua_var.buddy[buddy_id].blf_status.info[0].dialog_node) {
        info->dialog_id.ptr = info->buf_ + total;
        pj_strncpy(&info->dialog_id, &pjsua_var.buddy[buddy_id].blf_status.info[0].dialog_id, sizeof(info->buf_)-total);
        total += info->dialog_id.slen;

        info->dialog_call_id.ptr = info->buf_ + total;
        pj_strncpy(&info->dialog_call_id, &pjsua_var.buddy[buddy_id].blf_status.info[0].dialog_call_id, sizeof(info->buf_)-total);
        total += info->dialog_call_id.slen;

        info->dialog_remote_tag.ptr = info->buf_ + total;
        pj_strncpy(&info->dialog_remote_tag, &pjsua_var.buddy[buddy_id].blf_status.info[0].dialog_remote_tag, sizeof(info->buf_)-total);
        total += info->dialog_remote_tag.slen;

        info->dialog_local_tag.ptr = info->buf_ + total;
        pj_strncpy(&info->dialog_local_tag, &pjsua_var.buddy[buddy_id].blf_status.info[0].dialog_local_tag, sizeof(info->buf_)-total);
        total += info->dialog_local_tag.slen;

        info->dialog_direction.ptr = info->buf_ + total;
        pj_strncpy(&info->dialog_direction, &pjsua_var.buddy[buddy_id].blf_status.info[0].dialog_direction, sizeof(info->buf_)-total);
        total += info->dialog_direction.slen;

        info->dialog_state.ptr = info->buf_ + total;
        pj_strncpy(&info->dialog_state, &pjsua_var.buddy[buddy_id].blf_status.info[0].dialog_state, pjsua_var.buddy[buddy_id].blf_status.info[0].dialog_state.slen);
        total += info->dialog_state.slen;

        info->dialog_state_code.ptr = info->buf_ + total;
        pj_strncpy(&info->dialog_state_code, &pjsua_var.buddy[buddy_id].blf_status.info[0].dialog_state_code, pjsua_var.buddy[buddy_id].blf_status.info[0].dialog_state_code.slen);
        total += info->dialog_state_code.slen;

        info->dialog_duration.ptr = info->buf_ + total;
        pj_strncpy(&info->dialog_duration, &pjsua_var.buddy[buddy_id].blf_status.info[0].dialog_duration, pjsua_var.buddy[buddy_id].blf_status.info[0].dialog_duration.slen);
        total += info->dialog_duration.slen;

        if (pjsua_var.buddy[buddy_id].blf_status.info[0].local_identity.ptr) {
            info->local_identity.ptr = info->buf_ + total;
            pj_strncpy(&info->local_identity, &pjsua_var.buddy[buddy_id].blf_status.info[0].local_identity, pjsua_var.buddy[buddy_id].blf_status.info[0].local_identity.slen);
            total += info->local_identity.slen;
        }
        else
            info->local_identity = pj_str("NULL");

        if (pjsua_var.buddy[buddy_id].blf_status.info[0].local_identity_display.ptr) {
            info->local_identity_display.ptr = info->buf_ + total;
            pj_strncpy(&info->local_identity_display, &pjsua_var.buddy[buddy_id].blf_status.info[0].local_identity_display, pjsua_var.buddy[buddy_id].blf_status.info[0].local_identity_display.slen);
            total += info->local_identity_display.slen;
        }
        else
            info->local_identity_display = pj_str("NULL");

        if (pjsua_var.buddy[buddy_id].blf_status.info[0].local_target_uri.ptr) {
            info->local_target_uri.ptr = info->buf_ + total;
            pj_strncpy(&info->local_target_uri, &pjsua_var.buddy[buddy_id].blf_status.info[0].local_target_uri, pjsua_var.buddy[buddy_id].blf_status.info[0].local_target_uri.slen);
            total += info->local_target_uri.slen;
        }
        else
            info->local_target_uri = pj_str("NULL");

        if (pjsua_var.buddy[buddy_id].blf_status.info[0].remote_identity.ptr) {
            info->remote_identity.ptr = info->buf_ + total;
            pj_strncpy(&info->remote_identity, &pjsua_var.buddy[buddy_id].blf_status.info[0].remote_identity, pjsua_var.buddy[buddy_id].blf_status.info[0].remote_identity.slen);
            total += info->remote_identity.slen;
        }
        else
            info->remote_identity = pj_str("NULL");

        if (pjsua_var.buddy[buddy_id].blf_status.info[0].remote_identity_display.ptr) {
            info->remote_identity_display.ptr = info->buf_ + total;
            pj_strncpy(&info->remote_identity_display, &pjsua_var.buddy[buddy_id].blf_status.info[0].remote_identity_display, pjsua_var.buddy[buddy_id].blf_status.info[0].remote_identity_display.slen);
            total += info->remote_identity_display.slen;
        }
        else
            info->remote_identity_display = pj_str("NULL");

        if (pjsua_var.buddy[buddy_id].blf_status.info[0].remote_target_uri.ptr) {
            info->remote_target_uri.ptr = info->buf_ + total;
            pj_strncpy(&info->remote_target_uri, &pjsua_var.buddy[buddy_id].blf_status.info[0].remote_target_uri, pjsua_var.buddy[buddy_id].blf_status.info[0].remote_target_uri.slen);
            total += info->remote_target_uri.slen;
        }
        else
            info->remote_target_uri = pj_str("NULL");
    }

    /* subscription state and termination reason */
    info->sub_term_code = buddy->term_code;
    if (buddy->sub) {
        info->sub_state = pjsip_evsub_get_state(buddy->sub);
        info->sub_state_name = pjsip_evsub_get_state_name(buddy->sub);
        if (info->sub_state == PJSIP_EVSUB_STATE_TERMINATED &&
            total < sizeof(info->buf_))
        {
            info->sub_term_reason.ptr = info->buf_ + total;
            pj_strncpy(&info->sub_term_reason,
                   pjsip_evsub_get_termination_reason(buddy->sub),
                   sizeof(info->buf_) - total);
            total += info->sub_term_reason.slen;
        } else {
            info->sub_term_reason = pj_str("");
        }
    } else if (total < sizeof(info->buf_)) {
        info->sub_state_name = "NULL";
        info->sub_term_reason.ptr = info->buf_ + total;
        pj_strncpy(&info->sub_term_reason, &buddy->term_reason,
               sizeof(info->buf_) - total);
        total += info->sub_term_reason.slen;
    } else {
        info->sub_state_name = "NULL";
        info->sub_term_reason = pj_str("");
    }

    unlock_buddy(&lck);
    return PJ_SUCCESS;
}


/*
 * Add new buddy for blf
 */
PJ_DEF(pj_status_t) pjsua_buddy_add_blf( const pjsua_buddy_config *cfg,
                     pjsua_buddy_id *p_buddy_id)
{
    pjsip_name_addr *url;
    pjsua_buddy *buddy;
    pjsip_sip_uri *sip_uri;
    int index;
    pj_str_t tmp;

    PJ_ASSERT_RETURN(pjsua_var.buddy_cnt <= PJ_ARRAY_SIZE(pjsua_var.buddy),
             PJ_ETOOMANY);

    PJ_LOG(4,(THIS_FILE, "Adding buddy: %.*s", (int)cfg->uri.slen, cfg->uri.ptr));
    pj_log_push_indent();

    PJSUA_LOCK();

    /* Find empty slot */
    for (index = 0; index < (int)PJ_ARRAY_SIZE(pjsua_var.buddy); ++index) {
        if (pjsua_var.buddy[index].uri.slen == 0)
            break;
    }

    /* Expect to find an empty slot */
    if (index == PJ_ARRAY_SIZE(pjsua_var.buddy)) {
        PJSUA_UNLOCK();
        /* This shouldn't happen */
        pj_assert(!"index < PJ_ARRAY_SIZE(pjsua_var.buddy)");
        pj_log_pop_indent();
        return PJ_ETOOMANY;
    }

    buddy = &pjsua_var.buddy[index];

    /* Create pool for this buddy */
    if (buddy->pool) {
        pj_pool_reset(buddy->pool);
    } else {
        char name[PJ_MAX_OBJ_NAME];
        pj_ansi_snprintf(name, sizeof(name), "buddy%03d", index);
        buddy->pool = pjsua_pool_create(name, 512, 256);
    }

    /* Init buffers for presence subscription status */
    buddy->term_reason.ptr = (char*) pj_pool_alloc(buddy->pool,
                       PJSUA_BUDDY_SUB_TERM_REASON_LEN);

    /* Get name and display name for buddy */
    pj_strdup_with_null(buddy->pool, &tmp, &cfg->uri);
    url = (pjsip_name_addr*)pjsip_parse_uri(buddy->pool, tmp.ptr, tmp.slen,
                        PJSIP_PARSE_URI_AS_NAMEADDR);

    if (url == NULL) {
        pjsua_perror(THIS_FILE, "Unable to add buddy", PJSIP_EINVALIDURI);
        pj_pool_release(buddy->pool);
        buddy->pool = NULL;
        PJSUA_UNLOCK();
        pj_log_pop_indent();
        return PJSIP_EINVALIDURI;
    }

    /* Only support SIP schemes */
    if (!PJSIP_URI_SCHEME_IS_SIP(url) && !PJSIP_URI_SCHEME_IS_SIPS(url)) {
        pj_pool_release(buddy->pool);
        buddy->pool = NULL;
        PJSUA_UNLOCK();
        pj_log_pop_indent();
        return PJSIP_EINVALIDSCHEME;
    }

    /* Reset buddy, to make sure everything is cleared with default
     * values
     */
    reset_buddy(index);

    /* Save URI */
    pjsua_var.buddy[index].uri = tmp;

    sip_uri = (pjsip_sip_uri*) pjsip_uri_get_uri(url->uri);
    pjsua_var.buddy[index].name = sip_uri->user;
    pjsua_var.buddy[index].display = url->display;
    pjsua_var.buddy[index].host = sip_uri->host;
    pjsua_var.buddy[index].port = sip_uri->port;
    pjsua_var.buddy[index].monitor = cfg->subscribe;
    if (pjsua_var.buddy[index].port == 0)
        pjsua_var.buddy[index].port = 5060;

    /* Save user data */
    pjsua_var.buddy[index].user_data = (void*)cfg->user_data;

    if (p_buddy_id)
        *p_buddy_id = index;

    pjsua_var.buddy_cnt++;

    PJSUA_UNLOCK();

    PJ_LOG(4,(THIS_FILE, "Buddy %d added.", index));

    pjsua_buddy_subscribe_blf(index, cfg->subscribe);

    pj_log_pop_indent();
    return PJ_SUCCESS;
}

/*
 * Delete blf buddy.
 */
PJ_DEF(pj_status_t) pjsua_buddy_del_blf(pjsua_buddy_id buddy_id)
{
    struct buddy_lock lck;
    pj_status_t status;

    PJ_ASSERT_RETURN(buddy_id>=0 &&
			buddy_id<(int)PJ_ARRAY_SIZE(pjsua_var.buddy),
		     PJ_EINVAL);

    if (pjsua_var.buddy[buddy_id].uri.slen == 0) {
	return PJ_SUCCESS;
    }

    status = lock_buddy("pjsua_buddy_del_blf()", buddy_id, &lck, 0);
    if (status != PJ_SUCCESS)
	return status;

    PJ_LOG(4,(THIS_FILE, "BLF buddy %d: deleting..", buddy_id));
    pj_log_push_indent();

    /* Unsubscribe blf */
    pjsua_buddy_subscribe_blf(buddy_id, PJ_FALSE);

    /* Not interested with further events for this buddy */
    if (pjsua_var.buddy[buddy_id].sub) {
	pjsip_evsub_set_mod_data(pjsua_var.buddy[buddy_id].sub,
				 pjsua_var.mod.id, NULL);
    }

    /* Remove blf buddy */
    pjsua_var.buddy[buddy_id].uri.slen = 0;
    pjsua_var.buddy_cnt--;

    /* Clear timer */
    if (pjsua_var.buddy[buddy_id].timer.id) {
	pjsua_cancel_timer(&pjsua_var.buddy[buddy_id].timer);
	pjsua_var.buddy[buddy_id].timer.id = PJ_FALSE;
    }

    /* Reset blf buddy struct */
    reset_buddy(buddy_id);

    unlock_buddy(&lck);
    pj_log_pop_indent();
    return PJ_SUCCESS;
}

/*
 * Enable/disable buddy's presence monitoring.
 */
PJ_DEF(pj_status_t) pjsua_buddy_subscribe_blf( pjsua_buddy_id buddy_id,
                        pj_bool_t subscribe)
{
    struct buddy_lock lck;
    pj_status_t status;

    PJ_ASSERT_RETURN(pjsua_buddy_is_valid(buddy_id), PJ_EINVAL);

    status = lock_buddy("pjsua_buddy_subscribe_blf()", buddy_id, &lck, 0);
    if (status != PJ_SUCCESS)
        return status;

    PJ_LOG(4,(THIS_FILE, "Buddy %d: unsubscribing blf..", buddy_id));
    pj_log_push_indent();

    lck.buddy->monitor = subscribe;

    pjsua_buddy_update_blf(buddy_id);

    unlock_buddy(&lck);
    pj_log_pop_indent();
    return PJ_SUCCESS;
}

/* Callback called when *client* subscription state has changed. */
static void pjsua_evsub_on_blf_state( pjsip_evsub *sub, pjsip_event *event)
{
    pjsua_buddy *buddy;

    PJ_UNUSED_ARG(event);

    /* Note: #937: no need to acuire PJSUA_LOCK here. Since the buddy has
     *   a dialog attached to it, lock_buddy() will use the dialog
     *   lock, which we are currently holding!
     */
    buddy = (pjsua_buddy*) pjsip_evsub_get_mod_data(sub, pjsua_var.mod.id);
    if (buddy) {
    PJ_LOG(4,(THIS_FILE,
          "BLF subscription to %.*s is %s",
          (int)pjsua_var.buddy[buddy->index].uri.slen,
          pjsua_var.buddy[buddy->index].uri.ptr,
          pjsip_evsub_get_state_name(sub)));
    pj_log_push_indent();

    if (pjsip_evsub_get_state(sub) == PJSIP_EVSUB_STATE_TERMINATED) {
        int resub_delay = -1;

        if (buddy->term_reason.ptr == NULL) {
        buddy->term_reason.ptr = (char*)
                     pj_pool_alloc(buddy->pool,
                       PJSUA_BUDDY_SUB_TERM_REASON_LEN);
        }
        pj_strncpy(&buddy->term_reason,
               pjsip_evsub_get_termination_reason(sub),
               PJSUA_BUDDY_SUB_TERM_REASON_LEN);

        buddy->term_code = 200;

        /* Determine whether to resubscribe automatically */
        if (event && event->type==PJSIP_EVENT_TSX_STATE) {
        const pjsip_transaction *tsx = event->body.tsx_state.tsx;
        if (pjsip_method_cmp(&tsx->method,
                     &pjsip_subscribe_method)==0)
        {
            buddy->term_code = tsx->status_code;
            switch (tsx->status_code) {
            case PJSIP_SC_CALL_TSX_DOES_NOT_EXIST:
            /* 481: we refreshed too late? resubscribe
             * immediately.
             */
            /* But this must only happen when the 481 is received
             * on subscription refresh request. We MUST NOT try to
             * resubscribe automatically if the 481 is received
             * on the initial SUBSCRIBE (if server returns this
             * response for some reason).
             */
            if (buddy->dlg->remote.contact)
                resub_delay = 500;
            break;
            }
        } else if (pjsip_method_cmp(&tsx->method,
                        &pjsip_notify_method)==0)
        {
            if (pj_stricmp2(&buddy->term_reason, "deactivated")==0 ||
            pj_stricmp2(&buddy->term_reason, "timeout")==0) {
            /* deactivated: The subscription has been terminated,
             * but the subscriber SHOULD retry immediately with
             * a new subscription.
             */
            /* timeout: The subscription has been terminated
             * because it was not refreshed before it expired.
             * Clients MAY re-subscribe immediately. The
             * "retry-after" parameter has no semantics for
             * "timeout".
             */
            resub_delay = 500;
            }
            else if (pj_stricmp2(&buddy->term_reason, "probation")==0||
                 pj_stricmp2(&buddy->term_reason, "giveup")==0) {
            /* probation: The subscription has been terminated,
             * but the client SHOULD retry at some later time.
             * If a "retry-after" parameter is also present, the
             * client SHOULD wait at least the number of seconds
             * specified by that parameter before attempting to re-
             * subscribe.
             */
            /* giveup: The subscription has been terminated because
             * the notifier could not obtain authorization in a
             * timely fashion.  If a "retry-after" parameter is
             * also present, the client SHOULD wait at least the
             * number of seconds specified by that parameter before
             * attempting to re-subscribe; otherwise, the client
             * MAY retry immediately, but will likely get put back
             * into pending state.
             */
            const pjsip_sub_state_hdr *sub_hdr;
            pj_str_t sub_state = { "Subscription-State", 18 };
            const pjsip_msg *msg;

            msg = event->body.tsx_state.src.rdata->msg_info.msg;
            sub_hdr = (const pjsip_sub_state_hdr*)
                  pjsip_msg_find_hdr_by_name(msg, &sub_state,
                                 NULL);
            if (sub_hdr && sub_hdr->retry_after > 0)
                resub_delay = sub_hdr->retry_after * 1000;
            }

        }
        }

        /* For other cases of subscription termination, if resubscribe
         * timer is not set, schedule with default expiration (plus minus
         * some random value, to avoid sending SUBSCRIBEs all at once)
         */
        if (resub_delay == -1) {
        pj_assert(PJSUA_PRES_TIMER >= 3);
        resub_delay = PJSUA_PRES_TIMER*1000 - 2500 + (pj_rand()%5000);
        }

        buddy_resubscribe(buddy, PJ_TRUE, resub_delay);

    } else {
        /* This will clear the last termination code/reason */
        buddy->term_code = 0;
        buddy->term_reason.slen = 0;
    }

    /* Call callbacks */
    if (pjsua_var.ua_cfg.cb.on_buddy_evsub_blf_state)
        (*pjsua_var.ua_cfg.cb.on_buddy_evsub_blf_state)(buddy->index, sub,
                            event);

    if (pjsua_var.ua_cfg.cb.on_buddy_blf_state)
        (*pjsua_var.ua_cfg.cb.on_buddy_blf_state)(buddy->index);

    /* Clear subscription */
    if (pjsip_evsub_get_state(sub) == PJSIP_EVSUB_STATE_TERMINATED) {
        buddy->sub = NULL;
        buddy->status.info_cnt = 0;
        buddy->dlg = NULL;
        pjsip_evsub_set_mod_data(sub, pjsua_var.mod.id, NULL);
    }

    pj_log_pop_indent();
    }
}

/* Callback called when we receive blf NOTIFY */
static void pjsua_evsub_on_rx_blf_notify(pjsip_evsub *sub,
                     pjsip_rx_data *rdata,
                     int *p_st_code,
                     pj_str_t **p_st_text,
                     pjsip_hdr *res_hdr,
                     pjsip_msg_body **p_body)
{
    pjsua_buddy *buddy;

    /* Note: #937: no need to acuire PJSUA_LOCK here. Since the buddy has
     *   a dialog attached to it, lock_buddy() will use the dialog
     *   lock, which we are currently holding!
     */
    buddy = (pjsua_buddy*) pjsip_evsub_get_mod_data(sub, pjsua_var.mod.id);
    if (buddy) {
        /* Update our info. */
        pjsip_blf_get_status(sub, &buddy->blf_status);
    }

    /* The default is to send 200 response to NOTIFY.
     * Just leave it there..
     */
    PJ_UNUSED_ARG(rdata);
    PJ_UNUSED_ARG(p_st_code);
    PJ_UNUSED_ARG(p_st_text);
    PJ_UNUSED_ARG(res_hdr);
    PJ_UNUSED_ARG(p_body);
}

/* It does what it says.. */
static void subscribe_buddy_blf(pjsua_buddy_id buddy_id)
{
    pjsip_evsub_blf_user blf_callback;
    pj_pool_t *tmp_pool = NULL;
    pjsua_buddy *buddy;
    int acc_id;
    pjsua_acc *acc;
    pj_str_t contact;
    pjsip_tx_data *tdata;
    pj_status_t status;

    /* Event subscription callback. */
    pj_bzero(&blf_callback, sizeof(blf_callback));
    blf_callback.on_evsub_state = &pjsua_evsub_on_blf_state;
    blf_callback.on_tsx_state = &pjsua_evsub_on_tsx_state;
    blf_callback.on_rx_notify = &pjsua_evsub_on_rx_blf_notify;

    buddy = &pjsua_var.buddy[buddy_id];
    acc_id = pjsua_acc_find_for_outgoing(&buddy->uri);

    acc = &pjsua_var.acc[acc_id];

    PJ_LOG(4,(THIS_FILE, "Buddy %d: subscribing blf,using account %d..",
          buddy_id, acc_id));
    pj_log_push_indent();

    /* Generate suitable Contact header unless one is already set in
     * the account
     */
    if (acc->contact.slen) {
        contact = acc->contact;
    } else {
        tmp_pool = pjsua_pool_create("tmpbuddy", 512, 256);

        status = pjsua_acc_create_uac_contact(tmp_pool, &contact,
                              acc_id, &buddy->uri);
        if (status != PJ_SUCCESS) {
            pjsua_perror(THIS_FILE, "Unable to generate Contact header",
                     status);
            pj_pool_release(tmp_pool);
            pj_log_pop_indent();
            return;
        }
    }

    /* Create UAC dialog */
    status = pjsip_dlg_create_uac( pjsip_ua_instance(),
                   &acc->cfg.id,
                   &contact,
                   &buddy->uri,
                   NULL, &buddy->dlg);
    if (status != PJ_SUCCESS) {
    pjsua_perror(THIS_FILE, "Unable to create dialog", status);
    if (tmp_pool) pj_pool_release(tmp_pool);
        pj_log_pop_indent();
        return;
    }

    /* Increment the dialog's lock otherwise when presence session creation
     * fails the dialog will be destroyed prematurely.
     */
    pjsip_dlg_inc_lock(buddy->dlg);

    if (acc->cfg.allow_via_rewrite && acc->via_addr.host.slen > 0)
        pjsip_dlg_set_via_sent_by(buddy->dlg, &acc->via_addr, acc->via_tp);

    status = pjsip_blf_create_uac(buddy->dlg, &blf_callback,
                    PJSIP_EVSUB_NO_EVENT_ID, &buddy->sub);
    if (status != PJ_SUCCESS) {
        buddy->sub = NULL;
        pjsua_perror(THIS_FILE, "Unable to create blf client", status);
        /* This should destroy the dialog since there's no session
         * referencing it
         */
        if (buddy->dlg)
            pjsip_dlg_dec_lock(buddy->dlg);
        if (tmp_pool)
            pj_pool_release(tmp_pool);
        pj_log_pop_indent();
        return;
    }

    /* If account is locked to specific transport, then lock dialog
     * to this transport too.
     */
    if (acc->cfg.transport_id != PJSUA_INVALID_ID) {
        pjsip_tpselector tp_sel;

        pjsua_init_tpselector(acc->cfg.transport_id, &tp_sel);
        pjsip_dlg_set_transport(buddy->dlg, &tp_sel);
    }

    /* Set route-set */
    if (!pj_list_empty(&acc->route_set)) {
        pjsip_dlg_set_route_set(buddy->dlg, &acc->route_set);
    }

    /* Set credentials */
    if (acc->cred_cnt) {
        pjsip_auth_clt_set_credentials( &buddy->dlg->auth_sess,
                    acc->cred_cnt, acc->cred);
    }

    /* Set authentication preference */
    pjsip_auth_clt_set_prefs(&buddy->dlg->auth_sess, &acc->cfg.auth_pref);

    pjsip_evsub_set_mod_data(buddy->sub, pjsua_var.mod.id, buddy);

    status = pjsip_blf_initiate(buddy->sub, -1, &tdata);
    if (status != PJ_SUCCESS) {
        if (buddy->dlg)
            pjsip_dlg_dec_lock(buddy->dlg);
        if (buddy->sub) {
            pjsip_blf_terminate(buddy->sub, PJ_FALSE);
        }
        buddy->sub = NULL;
        pjsua_perror(THIS_FILE, "Unable to create initial SUBSCRIBE",
                 status);
        if (tmp_pool)
            pj_pool_release(tmp_pool);
        pj_log_pop_indent();
        return;
    }

    pjsua_process_msg_data(tdata, NULL);

    status = pjsip_blf_send_request(buddy->sub, tdata);
    if (status != PJ_SUCCESS) {
        if (buddy->dlg)
            pjsip_dlg_dec_lock(buddy->dlg);
        if (buddy->sub) {
            pjsip_blf_terminate(buddy->sub, PJ_FALSE);
        }
        buddy->sub = NULL;
        pjsua_perror(THIS_FILE, "Unable to send initial SUBSCRIBE",
                 status);
        if (tmp_pool) pj_pool_release(tmp_pool);
            pj_log_pop_indent();
        return;
    }

    pjsip_dlg_dec_lock(buddy->dlg);
    if (tmp_pool)
        pj_pool_release(tmp_pool);
    pj_log_pop_indent();
}

static void unsubscribe_buddy_blf(pjsua_buddy_id buddy_id)
{
    pjsua_buddy *buddy;
    pjsip_tx_data *tdata;
    pj_status_t status;

    buddy = &pjsua_var.buddy[buddy_id];

    if (buddy->sub == NULL)
        return;

    if (pjsip_evsub_get_state(buddy->sub) == PJSIP_EVSUB_STATE_TERMINATED) {
        buddy->sub = NULL;
        return;
    }

    PJ_LOG(5,(THIS_FILE, "Buddy %d: unsubscribing blf...", buddy_id));
    pj_log_push_indent();

    status = pjsip_blf_initiate( buddy->sub, 0, &tdata);
    if (status == PJ_SUCCESS) {
        pjsua_process_msg_data(tdata, NULL);
        status = pjsip_blf_send_request( buddy->sub, tdata );
    }

    if (status != PJ_SUCCESS && buddy->sub) {
        pjsip_blf_terminate(buddy->sub, PJ_FALSE);
        buddy->sub = NULL;
        pjsua_perror(THIS_FILE, "Unable to unsubscribe blf", status);
    }

    pj_log_pop_indent();
}

############# .../pjsip-apps/src/pjsua/pjsua_app.c

------------------------------------------------

+++ после on_buddy_state

/*
 * Handler on buddy blf state changed.
 */
static void on_buddy_blf_state(pjsua_buddy_id buddy_id)
{
    pjsua_buddy_blf_info info;
    pjsua_buddy_get_blf_info(buddy_id, &info);

    PJ_LOG(3,(THIS_FILE, "%.*s dialog-info-state: %.*s, dialog-info-version: %.*s, "
            "dialog-info-entity: %.*s, dialog-id: %.*s, dialog-call-id: %.*s, "
            "dialog-remote-tag: %.*s, dialog-local-tag: %.*s, dialog-direction: %.*s, "
            "dialog-state: %.*s, dialog-state-code: %.*s, dialog-duration: %.*s, "
            "local-identity: %.*s, local-target-uri: %.*s, remote-identity: %.*s, "
            "remote-target-uri: %.*s, subscription blf state: %s, (last termination "
            "reason code=%d %.*s)",
          (int)info.uri.slen,
          info.uri.ptr,
          (int)info.dialog_info_state.slen,
          info.dialog_info_state.ptr,
          (int)info.dialog_info_version.slen,
          info.dialog_info_version.ptr,
          (int)info.dialog_info_entity.slen,
          info.dialog_info_entity.ptr,
          (int)info.dialog_id.slen,
          info.dialog_id.ptr,
          (int)info.dialog_call_id.slen,
          info.dialog_call_id.ptr,
          (int)info.dialog_remote_tag.slen,
          info.dialog_remote_tag.ptr,
          (int)info.dialog_local_tag.slen,
          info.dialog_local_tag.ptr,
          (int)info.dialog_direction.slen,
          info.dialog_direction.ptr,
          (int)info.dialog_state.slen,
          info.dialog_state.ptr,
          (int)info.dialog_state_code.slen,
          info.dialog_state_code.ptr,
          (int)info.dialog_duration.slen,
          info.dialog_duration.ptr,
          (int)info.local_identity.slen,
          info.local_identity.ptr,
          (int)info.local_target_uri.slen,
          info.local_target_uri.ptr,
          (int)info.remote_identity.slen,
          info.remote_identity.ptr,
          (int)info.remote_target_uri.slen,
          info.remote_target_uri.ptr,
          info.sub_state_name,
          info.sub_term_code,
          (int)info.sub_term_reason.slen,
          info.sub_term_reason.ptr));
}

+++ после on_buddy_evsub_state

static void on_buddy_evsub_blf_state(pjsua_buddy_id buddy_id,
                 pjsip_evsub *sub,
                 pjsip_event *event)
{
    char event_info[80];

    PJ_UNUSED_ARG(sub);

    event_info[0] = '\0';

    if (event->type == PJSIP_EVENT_TSX_STATE &&
        event->body.tsx_state.type == PJSIP_EVENT_RX_MSG)
    {
        pjsip_rx_data *rdata = event->body.tsx_state.src.rdata;
        snprintf(event_info, sizeof(event_info),
             " (RX %s)",
             pjsip_rx_data_get_info(rdata));
    }

    PJ_LOG(4,(THIS_FILE,
          "Buddy %d: blf subscription state: %s (event: %s%s)",
          buddy_id, pjsip_evsub_get_state_name(sub),
          pjsip_event_str(event->type),
          event_info));
}


+++ в /pjsua_app_legacy.c keystroke_help

    puts("|                              | +d  Subscribe blf        |                   |");
    puts("|                              | -d  Subscribe blf        |                   |");

+++ в /pjsua_app_legacy.c legacy_main()

else if (menuin[1] == 'd') {
            pjsua_buddy_config buddy_cfg;
            pjsua_buddy_id buddy_id;
            pj_status_t status;

            if (!simple_input("Enter buddy's URI:", buf, sizeof(buf)))
                break;

            if (pjsua_verify_url(buf) != PJ_SUCCESS) {
                printf("Invalid URI '%s'\n", buf);
                break;
            }

            pj_bzero(&buddy_cfg, sizeof(pjsua_buddy_config));

            buddy_cfg.uri = pj_str(buf);
            buddy_cfg.subscribe = PJ_TRUE;

            status = pjsua_buddy_add_blf(&buddy_cfg, &buddy_id);
            if (status == PJ_SUCCESS) {
                printf("New buddy '%s' added at index %d\n",
                   buf, buddy_id+1);
            }
        } 

+++

else if (menuin[1] == 'd') {
		if (!simple_input("Enter blf buddy ID to delete",buf,sizeof(buf)))
		    break;

		i = my_atoi(buf) - 1;

		if (!pjsua_buddy_is_valid(i)) {
		    printf("Invalid buddy id %d\n", i);
		} else {
		    pjsua_buddy_del_blf(i);
		    printf("BLF buddy %d deleted\n", i);
        }
     } 



