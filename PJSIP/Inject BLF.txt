########### /pjsip/pjsip-simple/

>>> добавить blf.h и blf.c в (include) (src)
>>> добавить dialog_info.h и dialog_info.c в (include) (src)

>>> в /pjsip/build/Makefile
	+++ blf.o dialog-info.o


>>> модификация /pjsip/include/pjsip/sip_config.h

----------------------------------
#ifndef PJSIP_BLF_DEFAULT_EXPIRES
#   define PJSIP_BLF_DEFAULT_EXPIRES       600
#endif

#ifndef PJSIP_BLF_BAD_CONTENT_RESPONSE
#   define PJSIP_BLF_BAD_CONTENT_RESPONSE  488
#endif

--------------------------------------

>>> модификация evsub.h (include)

-----------------------------

struct pjsip_evsub_blf_user
{
    /**
     * This callback is called when subscription state has changed.
     * Application MUST be prepared to receive NULL event and events with
     * type other than PJSIP_EVENT_TSX_STATE
     *
     * This callback is OPTIONAL.
     *
     * @param sub   The subscription instance.
     * @param event The event that has caused the state to change,
     *          which may be NULL or may have type other than
     *          PJSIP_EVENT_TSX_STATE.
     */
    void (*on_evsub_state)( pjsip_evsub *sub, pjsip_event *event);

    /**
     * This callback is called when transaction state has changed.
     *
     * @param sub   The subscription instance.
     * @param tsx   Transaction.
     * @param event The event.
     */
    void (*on_tsx_state)(pjsip_evsub *sub, pjsip_transaction *tsx,
             pjsip_event *event);

    /**
     * This callback is called when incoming SUBSCRIBE (or any method that
     * establishes the subscription in the first place) is received. It
     * allows application to specify what response should be sent to
     * remote, along with additional headers and message body to be put
     * in the response.
     *
     * This callback is OPTIONAL.
     *
     * However, implementation MUST send NOTIFY request upon receiving this
     * callback. The suggested behavior is to call
     * #pjsip_evsub_current_notify(), since this function takes care
     * about unsubscription request and calculates the appropriate expiration
     * interval.
     */
    void (*on_rx_refresh)( pjsip_evsub *sub,
               pjsip_rx_data *rdata,
               int *p_st_code,
               pj_str_t **p_st_text,
               pjsip_hdr *res_hdr,
               pjsip_msg_body **p_body);

    /**
     * This callback is called when client/subscriber received incoming
     * NOTIFY request. It allows the application to specify what response
     * should be sent to remote, along with additional headers and message
     * body to be put in the response.
     *
     * This callback is OPTIONAL. When it is not implemented, the default
     * behavior is to respond incoming NOTIFY request with 200 (OK).
     *
     * @param sub   The subscription instance.
     * @param rdata The received NOTIFY request.
     * @param p_st_code Application MUST set the value of this argument with
     *          final status code (200-699) upon returning from the
     *          callback.
     * @param p_st_text Custom status text, if any.
     * @param res_hdr   Upon return, application can put additional headers
     *          to be sent in the response in this list.
     * @param p_body    Application MAY specify message body to be sent in
     *          the response.
     */
    void (*on_rx_notify)(pjsip_evsub *sub,
             pjsip_rx_data *rdata,
             int *p_st_code,
             pj_str_t **p_st_text,
             pjsip_hdr *res_hdr,
             pjsip_msg_body **p_body);

    /**
     * This callback is called when it is time for the client to refresh
     * the subscription.
     *
     * This callback is OPTIONAL when PJSIP package such as presence or
     * refer is used; the event package will refresh subscription by sending
     * SUBSCRIBE with the interval set to current/last interval.
     *
     * @param sub   The subscription instance.
     */
    void (*on_client_refresh)(pjsip_evsub *sub);

    /**
     * This callback is called when server doesn't receive subscription
     * refresh after the specified subscription interval.
     *
     * This callback is OPTIONAL when PJSIP package such as presence or
     * refer is used; the event package send NOTIFY to terminate the
     * subscription.
     */
    void (*on_server_timeout)(pjsip_evsub *sub);

};

/**
 * @see pjsip_evsub_user
 */
typedef struct pjsip_evsub_blf_user pjsip_evsub_blf_user;


-----------------------------


>>> модификация presence_body.c (src)


-----------------------------
 #include <pjsip-simple/blf.h>

+++

static const pj_str_t STR_DIALOG_INFO_XML = { "dialog-info+xml", 15 };

+++

PJ_DEF(pj_status_t) pjsip_blf_parse_dialog_info( pjsip_rx_data *rdata,
                       pj_pool_t *pool,
                       pjsip_blf_status *blf_status)
{
    return pjsip_blf_parse_dialog_info2((char*)rdata->msg_info.msg->body->data,
                  rdata->msg_info.msg->body->len,
                  pool, blf_status);
}

PJ_DEF(pj_status_t) pjsip_blf_parse_dialog_info2(char *body, unsigned body_len,
                       pj_pool_t *pool,
                       pjsip_blf_status *blf_status)
{
    pjdialog_info_dialog_info *dialog_info;
    pjdialog_info_dialog *dialog;

    dialog_info = pjdialog_info_parse(pool, body, body_len);
    if (dialog_info == NULL)
        return PJSIP_SIMPLE_EBADPIDF;

    blf_status->info_cnt = 0;

    dialog = pjdialog_info_dialog_info_get_dialog(dialog_info);
    pj_strdup(pool, &blf_status->info[blf_status->info_cnt].dialog_info_entity, pjdialog_info_dialog_info_get_entity(dialog_info));
    pj_strdup(pool, &blf_status->info[blf_status->info_cnt].dialog_info_state, pjdialog_info_dialog_info_get_state(dialog_info));
    pj_strdup(pool, &blf_status->info[blf_status->info_cnt].dialog_info_version, pjdialog_info_dialog_info_get_version(dialog_info));
    
    if (dialog)
    {
        blf_status->info[blf_status->info_cnt].dialog_node = pj_xml_clone(pool, dialog);

        pj_strdup(pool, &blf_status->info[blf_status->info_cnt].dialog_id, pjdialog_info_dialog_get_id(dialog));
        pj_strdup(pool, &blf_status->info[blf_status->info_cnt].dialog_call_id, pjdialog_info_dialog_get_call_id(dialog));
        pj_strdup(pool, &blf_status->info[blf_status->info_cnt].dialog_remote_tag, pjdialog_info_dialog_get_remote_tag(dialog));
        pj_strdup(pool, &blf_status->info[blf_status->info_cnt].dialog_local_tag, pjdialog_info_dialog_get_local_tag(dialog));
        pj_strdup(pool, &blf_status->info[blf_status->info_cnt].dialog_direction, pjdialog_info_dialog_get_direction(dialog));
        pj_strdup(pool, &blf_status->info[blf_status->info_cnt].dialog_state, pjdialog_info_dialog_get_state(dialog));
        pj_strdup(pool, &blf_status->info[blf_status->info_cnt].dialog_state_code, pjdialog_info_dialog_get_state_code(dialog));
        pj_strdup(pool, &blf_status->info[blf_status->info_cnt].dialog_duration, pjdialog_info_dialog_get_duration(dialog));

        pjdialog_info_local * local =pjdialog_info_dialog_get_local(dialog);
        if (local)
        {
            pj_strdup(pool, &blf_status->info[blf_status->info_cnt].local_identity, pjdialog_info_local_get_identity(local));
            pj_strdup(pool, &blf_status->info[blf_status->info_cnt].local_identity_display, pjdialog_info_local_get_identity_display(local));
            pj_strdup(pool, &blf_status->info[blf_status->info_cnt].local_target_uri, pjdialog_info_local_get_target_uri(local));
        }
        else {
            blf_status->info[blf_status->info_cnt].local_identity.ptr = NULL;
            blf_status->info[blf_status->info_cnt].local_identity_display.ptr = NULL;
            blf_status->info[blf_status->info_cnt].local_target_uri.ptr = NULL;
        }

        pjdialog_info_remote * remote =pjdialog_info_dialog_get_remote(dialog);
        if (remote)
        {
            pj_strdup(pool, &blf_status->info[blf_status->info_cnt].remote_identity, pjdialog_info_remote_get_identity(remote));
            pj_strdup(pool, &blf_status->info[blf_status->info_cnt].remote_identity_display, pjdialog_info_remote_get_identity_display(remote));
            pj_strdup(pool, &blf_status->info[blf_status->info_cnt].remote_target_uri, pjdialog_info_remote_get_target_uri(remote));
        }
        else {
            blf_status->info[blf_status->info_cnt].remote_identity.ptr = NULL;
            blf_status->info[blf_status->info_cnt].remote_identity_display.ptr = NULL;
            blf_status->info[blf_status->info_cnt].remote_target_uri.ptr = NULL;
        }
    }
    else
        blf_status->info[blf_status->info_cnt].dialog_node = NULL;
    return PJ_SUCCESS;
}


-----------------------------
